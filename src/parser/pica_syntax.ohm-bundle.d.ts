// AUTOGENERATED FILE
// This file was generated from pica_syntax.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface PicaActionDict<T> extends BaseActionDict<T> {
  Hadron?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  Ident_scopedIdent?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Ident_simpleIdent?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Ident?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  UseDecl_useNames?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: NonterminalNode) => T;
  UseDecl_useHadron?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  UseDecl?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Definition?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TypeParamBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  TypeParamList_list?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  TypeParamList_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TypeParamList?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TypeParamSpec?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  FlavorDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: NonterminalNode, arg5: IterationNode, arg6: NonterminalNode, arg7: IterationNode) => T;
  QuarkDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode, arg4: IterationNode, arg5: NonterminalNode, arg6: IterationNode, arg7: IterationNode, arg8: NonterminalNode, arg9: NonterminalNode, arg10: NonterminalNode, arg11: NonterminalNode, arg12: NonterminalNode, arg13: NonterminalNode, arg14: IterationNode) => T;
  BosonDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode, arg4: IterationNode, arg5: NonterminalNode, arg6: IterationNode) => T;
  BosonOptionDef_bosonTupleOption?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  BosonOptionDef_bosonStructOption?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  BosonOptionDef?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ChannelDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  Direction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ValueParamBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  TypedName?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  SlotDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  ProvidesBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  ComposesBlock?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  BehaviorDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: NonterminalNode, arg6: IterationNode) => T;
  Action?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ParAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode) => T;
  AssignAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  AdoptAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  SeqAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode) => T;
  SelectAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode) => T;
  SendAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  LocalAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode, arg5: NonterminalNode) => T;
  ReceiveAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: NonterminalNode, arg7: IterationNode) => T;
  RecvClause?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: NonterminalNode) => T;
  Pattern_tuple?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  Pattern_struct?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  Pattern?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StructFieldPattern?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  CondAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: NonterminalNode, arg5: IterationNode) => T;
  CondClause?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode) => T;
  WhileAction?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: IterationNode, arg4: NonterminalNode, arg5: IterationNode) => T;
  ExitAction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SType_namedType?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  SType_typeVar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SType_chanType?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  SType?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TypeParams?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicOp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicExpr_binaryLogic?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  LogicExpr_binaryFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CompareOp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CompareExpr_binaryCompare?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  CompareExpr_compareFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CompareExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddOp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddExpr_binaryAdd?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  AddExpr_addFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MultOp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MultExpr_binaryMult?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  MultExpr_multFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MultExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpExpr_binaryExp?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  ExpExpr_expFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  UnaryOp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  UnaryExpr_unaryWithOp?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  UnaryExpr_unaryFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  UnaryExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PostfixExpr_postfixField?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  PostfixExpr_postfixFallthrough?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PostfixExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PrimaryExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  VarRefExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ParenExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  CreateExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  BosonValueExpr_tuple?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  BosonValueExpr_struct?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode) => T;
  BosonValueExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  BosonStructField?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  plus?: (this: NonterminalNode, arg0: TerminalNode) => T;
  minus?: (this: NonterminalNode, arg0: TerminalNode) => T;
  times?: (this: NonterminalNode, arg0: TerminalNode) => T;
  div?: (this: NonterminalNode, arg0: TerminalNode) => T;
  mod?: (this: NonterminalNode, arg0: TerminalNode) => T;
  exp?: (this: NonterminalNode, arg0: TerminalNode) => T;
  eq?: (this: NonterminalNode, arg0: TerminalNode) => T;
  neq?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  eqeq?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  colon?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ceq?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  lt?: (this: NonterminalNode, arg0: TerminalNode) => T;
  le?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode) => T;
  gt?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ge?: (this: NonterminalNode, arg0: TerminalNode) => T;
  comma?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lparen?: (this: NonterminalNode, arg0: TerminalNode) => T;
  rparen?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lbrace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  rbrace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  lbrack?: (this: NonterminalNode, arg0: TerminalNode) => T;
  rbrack?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAnd?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAdopt?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwBehavior?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtBehavior?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwBoson?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtBoson?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwBoth?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwChan?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwComposes?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwCond?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtCond?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwCreate?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwDo?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwElse?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwEnd?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwExit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwFlavor?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtFlavor?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwFrom?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwIn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwIs?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwLocal?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwNot?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwOn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwOr?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwPar?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwProvides?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwOut?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwQuark?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtQuark?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwRecv?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtRecv?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwSelect?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwSend?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwSeq?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwSlot?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwThen?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwUse?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwWhile?: (this: NonterminalNode, arg0: TerminalNode) => T;
  kwAtWhile?: (this: NonterminalNode, arg0: TerminalNode) => T;
  keyword?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  uname?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  lname?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  tvar?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  digits?: (this: NonterminalNode, arg0: IterationNode) => T;
  decimalPart?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  expPart?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  strlit?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  nonQuoteOrBackslashChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  escapeSequence_backslash?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_doubleQuote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_newline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_carriageReturn?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_tab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_backspace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeSequence_unicodeCodePoint?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: IterationNode, arg7: NonterminalNode) => T;
  escapeSequence_unicodeEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  escapeSequence_hexEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  intlit?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  floatlit?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;
  charlit?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  whiteSpace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
}

export interface PicaSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: PicaActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: PicaActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: PicaActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: PicaActionDict<T>): this;
}

export interface PicaGrammar extends Grammar {
  createSemantics(): PicaSemantics;
  extendSemantics(superSemantics: PicaSemantics): PicaSemantics;
}

declare const grammar: PicaGrammar;
export default grammar;

